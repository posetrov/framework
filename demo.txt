компонентный фреймворк



фреймворк
	проект 
		библиотека1
		библиотека2

Controller


==============================

JavaScript

jQuery

NodeJS
	npm Webpack
	
	
------------------------------

Personal Home Page Tools

Hypertext Preprocessor

PHP 4 подобие ООП

2004 PHP 5.0 полноценное ООП

2012 Composer 

=============================

- Появление ООП в PHP
- Социальный кодинг GitHub
- Пакетный менеджер Composer


PictureManager

composer require pasha\picture-manager

Composer
	X1
	X2
	X3
	L1 -> X1,X3
	F1 -> X2, L1
	
monolog/monolog
guzzle/gizzle


Какие бывают запросы:
GET
POST
PUT
PATCH
DELETE


Первое правило, поддержания кодовой базы в чистоте,
и чтобы код было легче читать, это выносить фрагменты кода в функции.
Функция должна быть нацелена на решение какой-то одной задачи.
В идеале писать чистые функции, т.е. функция не должна менять что-то за своими пределами.
Следует группировать функции которые используются похожим образом в одном модуле(классе).
Важно давать осмысленные имена методам и свойствам класса.
Хорошая практика использовать type hinting для контроря параметров функции и возвращаемых значений.
Стоит продумать возможные ошибки и обрабатывать выбрашинные по ним исключения. 
Маштабируемый код должен быть SOLID.

Хороший разработчик должен писать код с минимумом багов даже до обработки кода юнит-тестами и тестировщиками. 
Тебе это удается? Если да, докажи на примерах. Как ты борешься с багами?

Ликвидировать нужно причину появления багов. Как бороться с багами? допускать меньше ошибок.
Как допускать меньше ошибок? анализировать ошибки ранее допущенные.
Для этого желательно вести БД багов, проводить категоризацию(для выявления жирных) багов, делать анализ(для фомирования шаблонов) багов, 
проверять гипотезы (для выявления первопричины).



5. Как ты относишься к работе по изменению чужого кода? Какие сложности возникают при работе с чужим кодом? Что не нравится в подобных случаях? 
Отношусь адекватно, это часть профессии. При работе с чужим кодом затрачивается больше мыслительного топлива(читать сложнее чем писать).
Рефакторинг приводит код к правильному виду, но и ничего не добавляет.



6. Разрабатывал ли ты когда-либо описание алгоритмов, схемы взаимодействия? 
Если да, приведи пример одного из самых интересных. В чем была главная сложность? 

Составлял UML диаграммы. Одна из таких диаграмм была по типу ETL. Главная сложность была в приведении данных к единому виду, из разрозненных систем.
